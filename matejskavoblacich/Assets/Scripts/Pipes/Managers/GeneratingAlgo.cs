using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.IO;
using System.Net.WebSockets;
using UnityEngine;
using UnityEngine.Rendering;

/// <summary>
/// structure for the path in the field that is generated by the algorithm
/// </summary>
public class PathTile{
    public Vector2 position;
    public Vector2 inDir = new Vector2(0,0);
    public Vector2 outDir = new Vector2(0,0);

    public PathTile(Vector2 pos){
        position = pos;
    }
};

/// <summary>
/// Hadles field generation, generates the path in the field, places bombs, walls, start and finnish
/// </summary>
public class GeneratingAlgo : MonoBehaviour
{
    [SerializeField, Range(1, 3), Tooltip("including walls")] int bombPaddingFromEdgeXAxis = 1;

    [SerializeField, Range(1, 3), Tooltip("including walls")] int bombPaddingFromEdgeYAxis = 1;

    [SerializeField, Range(1,2)] int distaceBetweenEndingPipes = 1;

    private int size = 0;

    private int obstacles = 0;

    private System.Random random;

    private void exceptionThrower (string arg) {
        throw new InvalidOperationException(arg);
    }

    /// <summary>
    /// Debuging print for the algorithm
    /// </summary>
    /// <param name="board">board that will be filled with the game objects</param>
    private void PrintBoard(Dictionary<Vector2, string> board){
        string matrixString = "\n";
        for (int row = 0; row < size; row++)
        {
            for (int col = 0; col < size; col++)
            {
                Vector2 pos = new Vector2(col, row);
                matrixString += board[pos];
            }
            matrixString += "\n";
        }
        // Debug.Log(matrixString);
    }

    /// <summary>
    /// Debuging print for the path that has been found in the field
    /// </summary>
    /// <param name="path"></param>
    private void PrintPath(List<PathTile> path){
        for(int i = 0; i < path.Count; i++){
            Debug.Log("Pos: " + path[i].position + " ,inDir: " + path[i].inDir + " ,outDir: " + path[i].outDir + '\n');
        }
    }

    private bool ValidateCoords(Vector2 coords)
    {
        return coords.x >= 0 && coords.y >= 0 && coords.x < size && coords.y < size;
    }

    private void PlaceString(Dictionary<Vector2, string> board, Vector2 pos, string str){
        board[pos] = str;
    }

    /// <summary>
    /// Inicializes starting and ending point in the field accoring to some rules
    /// Start and End need to be on the oposite sides and according to bombPaddingFromEdgeXAxis and bombPaddingFromEdgeXAxis there is a offset so that they arent on the same x on y possition
    /// </summary>
    /// <param name="board">playing field</param>
    /// <param name="size"></param>
    /// <returns></returns>
    private (Vector2, Vector2) InitializeStart(Dictionary<Vector2, string> board)
    {
        string side = new string[] { "top", "bottom", "left", "right" }[random.Next(0, 4)];
        int max_iter_ending_pipes = 1000000;

        Vector2 start, end;
        
        if (side == "top")
        {
            while(true){
                if(max_iter_ending_pipes == 0){
                    exceptionThrower("Could not place ending pipes");
                }
                start = new Vector2(0, random.Next(1, size - 1));
                end = new Vector2(size - 1, random.Next(1, size - 1));
                if(Math.Abs(end.y - start.y) > distaceBetweenEndingPipes){
                    break;
                }
                max_iter_ending_pipes--;
            }
            PlaceString(board, start, "S");
            PlaceString(board, end, "E");
        }
        else if (side == "bottom")
        {
            while(true){
                if(max_iter_ending_pipes == 0){
                    exceptionThrower("Could not place ending pipes");
                }
                start = new Vector2(size-1, random.Next(1, size - 1));
                end = new Vector2(0, random.Next(1, size - 1));
                if(Math.Abs(end.y - start.y) > distaceBetweenEndingPipes){
                    break;
                }
                max_iter_ending_pipes--;
            }
            PlaceString(board, start, "S");
            PlaceString(board, end, "E");
        }
        else if (side == "left")
        {
            while(true){
                if(max_iter_ending_pipes == 0){
                    exceptionThrower("Could not place ending pipes");
                }
                start = new Vector2(random.Next(1, size - 1), 0);
                end = new Vector2(random.Next(1, size - 1), size - 1);
                if(Math.Abs(end.x - start.x) > distaceBetweenEndingPipes){
                    break;
                }
                max_iter_ending_pipes--;
            }
            PlaceString(board, start, "S");
            PlaceString(board, end, "E");
        }
        else // "right"
        {
            while(true){
                if(max_iter_ending_pipes == 0){
                    exceptionThrower("Could not place ending pipes");
                }
                start = new Vector2(random.Next(1, size -1), size - 1);
                end = new Vector2(random.Next(1, size - 1), 0);
                if(Math.Abs(end.x - start.x) > distaceBetweenEndingPipes){
                    break;
                }
                max_iter_ending_pipes--;
            }
            PlaceString(board, start, "S");
            PlaceString(board, end, "E");
        }

        return (start, end);
    }

    /// <summary>
    /// makes deep copy of a playing board
    /// </summary>
    /// <param name="board"></param>
    /// <returns></returns>
    private Dictionary<Vector2, string> MakeDeepCopy(Dictionary<Vector2, string> board){
        Dictionary<Vector2, string> copy = new Dictionary<Vector2, string>();
        for(int i = 0; i < size; i++){
            for(int j = 0; j < size; j++){
                Vector2 pos = new Vector2(j, i);
                copy[pos] = new string(board[pos].ToCharArray());
            }
        }
        return copy;
    }

    /// <summary>
    /// Tries to place one obstacle to the field
    /// </summary>
    /// <param name="board">playing field</param>
    /// <param name="cnt">current number of tries to place a bomb</param>
    private void PlaceObstacles(Dictionary<Vector2, string> board, int cnt){
        if(cnt > 100){
            exceptionThrower("Could not place bombs acording to parametres");
        }
        int rx = random.Next(bombPaddingFromEdgeXAxis, size - bombPaddingFromEdgeXAxis);
        int ry = random.Next(bombPaddingFromEdgeYAxis, size - bombPaddingFromEdgeYAxis);
        Vector2 pos = new Vector2(rx, ry);

        if (board[pos] == "V")
        {
            board[pos] = "B";
        }
        else
        {
            PlaceObstacles(board, cnt+1); // Recursive call to try again if position is not empty
        }
    }

    /// <summary>
    /// reconstructs and return found path in the game field
    /// </summary>
    /// <param name="board"></param>
    /// <param name="start"></param>
    /// <param name="end"></param>
    /// <param name="P"></param>
    /// <returns></returns>
    private List<PathTile> ShowPath(Dictionary<Vector2, string> board, Vector2 start, Vector2 end, Dictionary<Vector2, Vector2> P)
    {
        List<PathTile> path = new List<PathTile>();
        PathTile endTile = new PathTile(end);
        PathTile startTile = new PathTile(start);
        path.Add(endTile);
        PathTile curr = endTile;
        while (curr.position != startTile.position)
        {
            curr = new PathTile(P[curr.position]);
            path.Add(curr);
        }
        path.Reverse();
        SymbolsPrint(board, start, end, path);
        return path;
    }

    /// <summary>
    /// prints given path to the board
    /// </summary>
    /// <param name="board"></param>
    /// <param name="start"></param>
    /// <param name="end"></param>
    /// <param name="path"></param>
    private void SymbolsPrint(Dictionary<Vector2, string> board, Vector2 start, Vector2 end, List<PathTile> path)
    {
        for (int i = 1; i < path.Count - 1; i++)
        {
            board[path[i].position] = "#";
        }
    }

    /// <summary>
    /// method to procces neighboar in BFS algorithm
    /// </summary>
    /// <param name="next"></param>
    /// <param name="prev"></param>
    /// <param name="board"></param>
    /// <param name="P"></param>
    /// <param name="q"></param>
    /// <param name="visited"></param>
    private void ProcessNeigh(Vector2 next, Vector2 prev, Dictionary<Vector2, string> board, Dictionary<Vector2, Vector2> P, Queue<Vector2> q, HashSet<Vector2> visited)
    {
        if (ValidateCoords(next) && !visited.Contains(next) && (board[next] == "V" || board[next] == "E"))
        {
            P[next] = prev;
            q.Enqueue(next);
            visited.Add(next);
        }
    }

    /// <summary>
    /// BFS algorithm to find the shortest path in the field between start and end
    /// </summary>
    /// <param name="(Dictionary<Vector2"></param>
    /// <param name="board"></param>
    /// <param name="start"></param>
    /// <param name="end"></param>
    /// <returns></returns>
    private (bool, Dictionary<Vector2, string>, List<PathTile>) BFS (Dictionary<Vector2, string> board, Vector2 start, Vector2 end){
        HashSet<Vector2> visited = new HashSet<Vector2>();
        Dictionary<Vector2, Vector2> P = new Dictionary<Vector2, Vector2>();
        Queue<Vector2> q = new Queue<Vector2>();
        List<PathTile> path = new List<PathTile>();
        bool found = false;

        q.Enqueue(start);
        visited.Add(start);

        while (q.Count > 0)
        {
            Vector2 curr = q.Dequeue();
            if (curr == end)
            {
                found = true;
                path = ShowPath(board, start, end, P);
                break;
            }
            else
            {
                ProcessNeigh(new Vector2(curr.x + 1, curr.y), curr, board, P, q, visited);
                ProcessNeigh(new Vector2(curr.x - 1, curr.y), curr, board, P, q, visited);
                ProcessNeigh(new Vector2(curr.x, curr.y + 1), curr, board, P, q, visited);
                ProcessNeigh(new Vector2(curr.x, curr.y - 1), curr, board, P, q, visited);
            }
        }

        return (found, board, path);
    }

    /// <summary>
    /// Tries to place given number of bombs to the field and the construct the path from the start to end
    /// </summary>
    /// <param name="ObstaclesAndPath(Dictionary<Vector2"></param>
    /// <param name="board"></param>
    /// <param name="start"></param>
    /// <param name="end"></param>
    /// <returns>either filled board and path or tries it with another obstacle possiton</returns>
    private (Dictionary<Vector2, string>, List<PathTile>) ObstaclesAndPath(Dictionary<Vector2, string> board, Vector2 start, Vector2 end){
        Dictionary<Vector2, string> copy = MakeDeepCopy(board);
        for(int i = 0; i < obstacles; i++){
            PlaceObstacles(copy, 0);
        }
        (bool found, Dictionary<Vector2, string> nboard, List<PathTile> path) = BFS(copy, start, end);
        if(found){
            return (copy, path);
        }
        else{
            return ObstaclesAndPath(board, start, end);
        }
    }

    /// <summary>
    /// gives every element in path its income and outcome element
    /// </summary>
    /// <param name="path"></param>
    private void ManagePath(List<PathTile> path){
        for(int i = 1; i < path.Count - 1; i++){
            path[i].inDir = new Vector2(-(path[i].position.x - path[i-1].position.x), -(path[i].position.y - path[i-1].position.y));
            path[i].outDir = new Vector2(-(path[i].position.x - path[i+1].position.x), -(path[i].position.y - path[i+1].position.y));
        }

        path[0].inDir = new Vector2(0,0);
        path[0].outDir = new Vector2(-(path[0].position.x - path[1].position.x), -(path[0].position.y - path[1].position.y));
        path[path.Count - 1].inDir = new Vector2(-(path[path.Count - 1].position.x - path[path.Count - 2].position.x), -(path[path.Count - 1].position.y - path[path.Count - 2].position.y));
        path[path.Count - 1].outDir = new Vector2(0,0);
    }

    /// <summary>
    /// main method that handles generating of the correct game board
    /// </summary>
    /// <param name="ssize"></param>
    /// <param name="oobstacles"></param>
    /// <param name="seed"></param>
    /// <returns>board and the path in the board</returns>
    public (Dictionary<Vector2, string>, List<PathTile>) GenerateMap(int ssize, int oobstacles, int seed)
    {
        size = ssize;
        obstacles = oobstacles;
        Dictionary<Vector2, string> board = new Dictionary<Vector2, string>();
        List<PathTile> path;
        random = new System.Random(seed);

        for (int i = 0; i < size; i++)
        {
            for (int j = 0; j < size; j++)
            {
                if(i == 0 || j == 0 || i == size - 1 || j == size -1){
                    board[new Vector2(j, i)] = "X";
                }
                else{
                    board[new Vector2(j, i)] = "V";
                }
            }
        }

        (Vector2 start, Vector2 end) = InitializeStart(board);
        (board, path) = ObstaclesAndPath(board, start, end);
        PrintBoard(board);
        ManagePath(path);
        // PrintPath(path);
        return (board, path);
    }
    
}
